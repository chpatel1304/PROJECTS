1) GETTING EMPLOYEE PERSONAL DETAILS AND DESIGNATION DETAILS BY HIS/HER ID :
CREATE OR REPLACE PROCEDURE GET_EMP_DEATILS_DESIGNATION1(IN_ID INT)AS
$$
DECLARE

CHECK_S INT;
O_ID EMPLOYEE.E_ID%TYPE;
FIRST EMPLOYEE.E_FIRSTNAME%TYPE;
LAST EMPLOYEE.E_LASTNAME%TYPE;
AGE EMPLOYEE.E_AGE%TYPE;
EMAIL EMPLOYEE.E_MAIL%TYPE;
NUMBER EMPLOYEE.E_NUMBER%TYPE;
DOB EMPLOYEE.E_DOB%TYPE;
DESIGN EMP_DESIGNATION.E_DESIGNATION%TYPE;
SALARY EMP_DESIGNATION.E_SALARY%TYPE;
JOINING EMP_DESIGNATION.E_JOININGDATE%TYPE;
PRECOM EMP_DESIGNATION.E_PREVIOUSCOMPANY%TYPE;

BEGIN

SELECT COUNT(E_ID) INTO CHECK_S FROM EMPLOYEE WHERE E_ID=IN_ID;
IF(CHECK_S>0) THEN
SELECT E_ID,E_FIRSTNAME,E_LASTNAME,E_AGE,E_MAIL,E_NUMBER,E_DOB INTO O_ID,FIRST,LAST,AGE,EMAIL,NUMBER,DOB FROM EMPLOYEE WHERE E_ID=IN_ID;
SELECT E_DESIGNATION,E_SALARY,E_JOININGDATE,E_PREVIOUSCOMPANY INTO DESIGN,SALARY,JOINING,PRECOM FROM EMP_DESIGNATION WHERE E_ID=IN_ID;
RAISE NOTICE 'EMPLOYEE ID : %   EMPLOYEE NAME : % % ',O_ID,FIRST,LAST;
RAISE NOTICE 'EMPLOYEE AGE : %   EPMPLOYEE EMAIL : %  EMPLOYEE NUMBER : %',AGE,EMAIL,NUMBER;
RAISE NOTICE 'EMPLOYEE DOB : % EMPLOYEE DESIGANTION : % EMPLOYEE SALARY : % ',DOB,DESIGN,SALARY;
RAISE NOTICE 'EMPLOYEE JOIN DATE : % EMPLOYEE PREVIOUS COMPANY : % ',JOINING,PRECOM;
ELSE 
RAISE NOTICE 'EMPLOYEE DOESNOT EXIST !';
END IF;

END;
$$
LANGUAGE PLPGSQL;
CALL GET_EMP_DEATILS_DESIGNATION1(1);
---------------------------------------------------------------------------------------------------------------------------------------------------------------
2)  GETTING ADMINS PERSONAL DETAILS AND DESIGNATION DETAILS BY HIS/HER ID :

CREATE OR REPLACE PROCEDURE GET_ADM_DEATILS_DESIGNATION2(IN_ID INT)AS
$$
DECLARE
CHECK_S INT;
O_ID ADMINISTRATION.A_ID%TYPE;
FIRST ADMINISTRATION.A_FIRSTNAME%TYPE;
LAST ADMINISTRATION.A_LASTNAME%TYPE;
AGE ADMINISTRATION.A_AGE%TYPE;
EMAIL ADMINISTRATION.A_EMAIL%TYPE;
NUMBER ADMINISTRATION.A_NUMBER%TYPE;
DOB ADMINISTRATION.A_DOB%TYPE;
DESIGN ADMIN_DESIGNATION.A_DESIGNATION%TYPE;
SALARY ADMIN_DESIGNATION.A_SALARY%TYPE;
PREPOS ADMIN_DESIGNATION.A_PREVIOUSPOST%TYPE;
PRECOM ADMIN_DESIGNATION.A_PREVIOUSCOMPANY%TYPE;

BEGIN

SELECT COUNT(A_ID) INTO CHECK_S FROM ADMINISTRATION WHERE A_ID=IN_ID;
IF(CHECK_S>0) THEN
SELECT A_ID,A_FIRSTNAME,A_LASTNAME,A_AGE,A_EMAIL,A_NUMBER,A_DOB INTO O_ID,FIRST,LAST,AGE,EMAIL,NUMBER,DOB FROM ADMINISTRATION WHERE A_ID=IN_ID;
SELECT A_DESIGNATION,A_SALARY,A_PREVIOUSCOMPANY,A_PREVIOUSPOST INTO DESIGN,SALARY,PRECOM,PREPOS FROM ADMIN_DESIGNATION WHERE A_ID=IN_ID;
RAISE NOTICE 'ADMIN ID : %   ADMIN NAME : % % ',O_ID,FIRST,LAST;
RAISE NOTICE 'ADMIN AGE : %  ADMIN EMAIL : %  ADMIN NUMBER : %',AGE,EMAIL,NUMBER;
RAISE NOTICE 'ADMIN DOB : % ADMIN DESIGANTION : % ADMIN SALARY : % ',DOB,DESIGN,SALARY;
RAISE NOTICE ' ADMIN PREVIOUS COMPANY : %  ADMIN PREVIOUS POST : % ',PRECOM,PREPOS;
ELSE 
RAISE NOTICE 'ADMIN DOESNOT EXIST !';
END IF;

END;
$$
LANGUAGE PLPGSQL;
CALL GET_ADM_DEATILS_DESIGNATION2(20);
---------------------------------------------------------------------------------------------------------------------------------------------------------------
3) GETTING MAX SALARY OF EMPLOYEE/ADMINISTARTION BY ENTERING DESIGNATION NAME

CREATE OR REPLACE FUNCTION GET_MAX_SALARY_BY_DESIGN(DESIGNATION VARCHAR(20)) RETURNS INT AS
$$
DECLARE
MAX_SALARY INT;
BEGIN
SELECT MAX(E_SALARY) INTO MAX_SALARY FROM EMP_DESIGNATION WHERE E_DESIGNATION=DESIGNATION;
RETURN MAX_SALARY;
END;
$$
LANGUAGE PLPGSQL;
SELECT GET_MAX_SALARY_BY_DESIGN('MARKETING');
---------------------------------------------------------------------------------------------------------------------------------------------------------------
4)  GETTING ADMINISTRATIONS LIST BY DESIGNATION


CREATE OR REPLACE PROCEDURE GET_ADMININTRATIONS_BY_DESIGNATION(IN_D VARCHAR(30)) AS
$$
DECLARE
FIRST ADMINISTRATION.A_FIRSTNAME%TYPE;
LAST ADMINISTRATION.A_LASTNAME%TYPE;
DESIGN ADMIN_DESIGNATION.A_DESIGNATION%TYPE;
SALARY ADMIN_DESIGNATION.A_SALARY%TYPE;
C1 CURSOR FOR SELECT ADMINISTRATION.A_FIRSTNAME,ADMINISTRATION.A_LASTNAME,ADMIN_DESIGNATION.A_DESIGNATION,
ADMIN_DESIGNATION.A_SALARY FROM ADMIN_DESIGNATION INNER JOIN ADMINISTRATION 
ON ADMINISTRATION.A_ID=ADMIN_DESIGNATION.A_ID WHERE A_DESIGNATION=IN_D;
BEGIN
OPEN C1;
LOOP
FETCH C1 INTO FIRST,LAST,DESIGN,SALARY;
EXIT WHEN NOT FOUND;
RAISE NOTICE 'ADMINISTRATION NAME: % % 
              ADMINISTRAION DESIGNATION : %
			  ADMINISTRATION SALARY : % ',FIRST,LAST,DESIGN,SALARY;
END LOOP;
CLOSE C1;
END;
$$
LANGUAGE PLPGSQL;
-- CALL GET_ADMININTRATIONS_BY_DESIGNATION('HOD');
---------------------------------------------------------------------------------------------------------------------------------------------------------------
5) TRIIGERS ON INSERTION WHEN OLD ID IS INSETRED AGAIN OR NEGATIVE ID IS INSERTED IN TABLE :

CREATE OR REPLACE FUNCTION CHECK_E_ID()returns trigger as 
$$
DECLARE
CHECK_E INT;
BEGIN
SELECT COUNT(*) INTO CHECK_E FROM EMPLOYEE WHERE E_ID=NEW.E_ID;
IF NEW.E_ID <0 THEN
RAISE 'LESSS THAN ZERO VALUE NOT ALLOWED';
ELSE 
IF CHECK_E >0 THEN
RAISE 'THAT ID ALREAFDY EXIST !';
END IF;
END IF;
RETURN NEW;
END;
$$
LANGUAGE PLPGSQL;

CREATE TRIGGER CHECK_E_ID 
BEFORE INSERT ON EMPLOYEE
FOR EACH ROW 
EXECUTE PROCEDURE CHECK_E_ID();

INSERT INTO employee (E_ID, E_FIRSTNAME, E_LASTNAME, E_AGE, E_MAIL, E_NUMBER, E_DOB)
VALUES
  (-1, 'Amit', 'Kumar', 28, 'amit.kumar@example.com', '9876543210', '1995-07-15');

---------------------------------------------------------------------------------------------------------------------------------------------------------------

6) GETTING EMPLOYEES AND ADMINS BY ENTERING DEPARTAMENT NAME 
CREATE OR REPLACE PROCEDURE GET_EMP_ADM_BY_DEPT(DEPART VARCHAR(20)) AS
$$
DECLARE 
FIRST_E EMPLOYEE.E_FIRSTNAME%TYPE;
LAST_E   EMPLOYEE.E_LASTNAME%TYPE;
FIRST_A ADMINISTRATION.A_FIRSTNAME%TYPE;
LAST_A   ADMINISTRATION.A_LASTNAME%TYPE;
C1 CURSOR FOR SELECT EMPLOYEE.E_FIRSTNAME,EMPLOYEE.E_LASTNAME FROM EMPLOYEE INNER JOIN DEPARTMENT 
ON EMPLOYEE.E_ID=DEPARTMENT.E_ID WHERE D_NAME=DEPART;

C2 CURSOR FOR SELECT ADMINISTRATION.A_FIRSTNAME,ADMINISTRATION.A_LASTNAME FROM ADMINISTRATION INNER JOIN DEPARTMENT 
ON ADMINISTRATION.A_ID=DEPARTMENT.A_ID WHERE D_NAME=DEPART;

BEGIN
OPEN C1;
OPEN C2;
LOOP
FETCH C1 INTO FIRST_E,LAST_E;
EXIT WHEN NOT FOUND;
RAISE NOTICE 'EMPLOYEEE LIST : % % ',FIRST_E,LAST_E;
END LOOP;
LOOP
FETCH C2 INTO FIRST_A,LAST_A;
EXIT WHEN NOT FOUND;
RAISE NOTICE 'ADMIN LIST : % % ',FIRST_A,LAST_A;
END LOOP;
CLOSE C2;
CLOSE C1;
END;
$$
LANGUAGE PLPGSQL;
-- CALL GET_EMP_ADM_BY_DEPT('ACCOUNTS');

---------------------------------------------------------------------------------------------------------------------------------------------------------------

7)   ENTER THE SALARY AND INCREMENT PERECENATGE AND QUERY WILL INCREMENTS ALL EMPLOYEE'S SALARY WHO IS LESS THAN ENTERED SLARY ;
CREATE OR REPLACE PROCEDURE UPDATE_SALARY1(I_SALARY INT, INCR INT) AS 
$$
DECLARE
    INCREMENTED INT;
    NEW_SAL INT;
    FIRST ADMINISTRATION.A_FIRSTNAME%TYPE;
    LAST ADMINISTRATION.A_LASTNAME%TYPE;
    DESIGN ADMIN_DESIGNATION.A_DESIGNATION%TYPE;
    SALARY ADMIN_DESIGNATION.A_SALARY%TYPE;
    C1 CURSOR FOR SELECT ADMINISTRATION.A_FIRSTNAME, ADMINISTRATION.A_LASTNAME, ADMIN_DESIGNATION.A_DESIGNATION, ADMIN_DESIGNATION.A_SALARY
                 FROM ADMIN_DESIGNATION
                 INNER JOIN ADMINISTRATION ON ADMINISTRATION.A_ID = ADMIN_DESIGNATION.A_ID
                 WHERE A_SALARY > I_SALARY;
BEGIN
    INCREMENTED := INCR / 100;
    OPEN C1;
    LOOP
        FETCH C1 INTO FIRST, LAST, DESIGN, SALARY;
        EXIT WHEN NOT FOUND;
        
        RAISE NOTICE 'ADMIN NAME : % %', FIRST, LAST;
        RAISE NOTICE 'ADMIN OLD SALARY : %', SALARY;
        
        NEW_SAL := SALARY + (INCREMENTED * SALARY);
        RAISE NOTICE 'ADMIN NEW SALARY : %', NEW_SAL;
        
        -- Update the salary in the ADMIN_DESIGNATION table
--         UPDATE ADMIN_DESIGNATION
--         SET A_SALARY = NEW_SAL
--         WHERE CURRENT OF C1;
    END LOOP;
    CLOSE C1;
    
    -- Commit the changes to the database
    COMMIT;
END;
$$
LANGUAGE PLPGSQL;
-- CALL UPDATE_SALARY1(50000,10);
---------------------------------------------------------------------------------------------------------------------------------------------------------------
8) GET HOW MANY NUMBERS OF EMPLOYEES 
   
CREATE OR REPLACE FUNCTION GET_EMPLOYEE_COUNT_BY_DESIGNATION(DESIGN VARCHAR(30)) RETURNS INT AS
$$
DECLARE
COUNTER INT;
BEGIN
SELECT COUNT(E_ID) INTO COUNTER FROM EMP_DESIGNATION WHERE E_DESIGNATION=DESIGN;
RETURN COUNTER;
END;
$$
LANGUAGE PLPGSQL;
SELECT GET_EMPLOYEE_COUNT_BY_DESIGNATION('MARKETING');

